# 字符串

## 1. 旋转字符串

#### 题目描述：

给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 解法：

将一个字符串分成X和Y两个部分，在每部分字符串上定义反转操作，如X^T，即把X的所有字符反转（如，X="abc"，那么X^T="cba"），那么就得到下面的结论：(X^TY^T)^T=YX，显然就解决了字符串的反转问题。

例如，字符串 abcdef ，若要让def翻转到abc的前头，只要按照下述3个步骤操作即可：

1.  首先将原字符串分为两个部分，即X:abc，Y:def；
2.  将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
3.  反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。

[代码：str-1.java]()

#### 思考题

**问题**：单词翻转。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变，句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。例如，输入“I am a student.”，则输出“student. a am I”。

**思路**： 可以以空格为分隔符，将字符串分为多个字符串，然后再对各个字符串进行反转，再将反转后的多个字符串拼接为一个字符串，最终将拼接后的一个字符串反转，即可实现。

## 2. 字符串包含 

#### 题目描述：

给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？

##### 解法一：

如果允许排序的话，我们可以考虑下排序。比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。

##### 解法二：

假设有一个仅由字母组成字串，让每个字母与一个素数对应，从2开始，往后类推，A对应2，B对应3，C对应5，......。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。

利用上面字母和素数的对应关系，对应第二个字符串中的字母，然后轮询，用每个字母对应的素数除前面得到的整数。如果结果有余数，说明结果为false。如果整个过程中没有余数，则说明第二个字符串是第一个的子集了（判断是不是真子集，可以比较两个字符串对应的素数乘积，若相等则不是真子集）。

思路总结如下：

1.  按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。
2.  遍历长字符串，求得每个字符对应素数的乘积。
3.  遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。
4.  输出结果。

算法的时间复杂度为O(m+n)的最好的情况为O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回false），n为长字串的长度，空间复杂度为O(1)。

**缺点**是素数相乘的结果容易导致整数溢出。

##### 解法三：

先把长字符串a中的所有字符都放入一个Hashtable里，然后轮询短字符串b，看短字符串b的每个字符是否都在Hashtable里，如果都存在，说明长字符串a包含短字符串b，否则，说明不包含。

再进一步，我们可以对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。

[代码：str-2.java]()

## 3. 字符串转整数

#### 题目描述：

输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串"123"，输出整数123。不能使用库函数。

#### 解法：

此题重点考察：

1.  空指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。
2.  正负符号：整数不仅包含数字，还有可能是以'+'或'-'开头表示正负整数，因此如果第一个字符是'-'号，则要把得到的整数转换成负整数。
3.  非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。
4.  整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。

在进行字符串转整数的过程中，其中一步可能会导致结果产生溢出问题，之后的关于溢出处理已俨然无用。所以，对于溢出的处理，应在溢出产生之前进行。一种巧妙的方法就是只比较结果 n 和 MAX_INT / 10 的大小。

[代码：str-3.java]()

## 4. 回文判断

可从两边或中间维护两个指针，一直判断这两个指针的值是否相同就可以。

## 5. 最长回文字串

#### 题目描述：

 给定一个字符串，求它的最长回文子串的长度。

#### 分析：

最容易想到的办法是枚举所有的子串，分别判断其是否为回文。这个思路初看起来是正确的，但却做了很多无用功，如果一个长的子串包含另一个短一些的子串，那么对子串的回文判断其实是不需要的。

##### 解法一：

如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。

我们可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度。

##### 解法二 Manacher 算法：

Manacher 算法主要解决解法一存在的两个缺点：

1.  字符串长度奇偶性带来的对称轴问题。
2.  字符串元素重复访问的问题。

主要解决思路：

1.  Manacher算法首先对字符串做一个预处理，在所有的空隙位置(包括首尾)插入同样的符号，要求这个符号是不会在原串中出现的。这样会使得所有的串都是奇数长度的。如：`abba ———>  #a#b#b#a#`，插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文。
2.  [详见](https://segmentfault.com/a/1190000003914228)

[代码：str-5.java]()

## 6. 字符串的全排列

#### 题目描述：

输入一个字符串，打印出该字符串中字符的所有排列。

例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串 abc、acb、bac、bca、cab 和 cba。

#### 解法：

##### 解法一：递归实现

如果能生成n-1个元素的全排列，就能生成n个元素的全排列。对于只有一个元素的集合，可以直接生成全排列。所以全排列的递归终止条件很明确，只有一个元素时。我们可以分析一下全排列的过程：（以 abc 为例）

1.  首先，我们固定第一个字符a，求后面两个字符bc的排列
2.  当两个字符bc排列求好之后，我们把第一个字符a和后面的b交换，得到bac，接着我们固定第一个字符b，求后面两个字符ac的排列
3.  现在是把c放在第一个位置的时候了，但是记住前面我们已经把原先的第一个字符a和后面的b做了交换，为了保证这次c仍是和原先处在第一个位置的a交换，我们在拿c和第一个字符交换之前，先要把b和a交换回来。在交换b和a之后，再拿c和处于第一位置的a进行交换，得到cba。我们再次固定第一个字符c，求后面两个字符b、a的排列。

[递归求解字符串代码：str-6.1.java]()

##### 解法二：字典序排列

字典序：给定两个字符串，逐个字符比较，那么先出现较小字符的那个串字典顺序小，如果字符一直相等，较短的串字典顺序小。

STL中的next_permutation算法：

- 起点： 字典序最小的排列, 1-n , 例如12345
- 终点： 字典序最大的排列，n-1, 例如54321
- 过程： 从当前排列生成字典序刚好比它大的下一个排列

定义：

1. 升序：相邻两个位置ai < ai+1，ai 称作该升序的首位。

步骤：

1. 找到排列中最后（最右）一个升序的首位位置i，x = ai；
2. 找到排列中第i位右边最后一个比ai 大的位置j，y = aj；
3. 交换x，y；
4. 把第(i+ 1)位到最后的部分翻转。

[字典序排列求解字符串全排列代码：str-6.2.java]()

#### 总结：

递归求解法对于重复字符串存在重复求解的问题，而字典序法不存在这个问题。

由于全排列总共有n!种排列情况，所以不论解法一中的递归方法，还是上述解法二的字典序排列方法，这两种方法的时间复杂度都为O(n!)。

#### 思考题

1. 已知字符串里的字符是互不相同的，现在任意组合，比如ab，则输出aa，ab，ba，bb，编程按照字典序输出所有的组合。

   可用递归的思想，设置一个变量表示已输出的个数，然后当个数达到字符串长度时，就输出。

   ```java
   public static void perm(char[] str, char[] result, int size, int resPos){
        if (resPos == size){
           printStr(result);
           System.out.println();
       }else {
           for (int i = 0 ; i < size; i++){
               result[resPos] = str[i];
               perm(str, result, size, resPos+1);
           }
       }
   }
   ```

2. 如果不是求字符的所有排列，而是求字符的所有组合，应该怎么办呢？当输入的字符串中含有相同的字符串时，相同的字符交换位置是不同的排列，但是同一个组合。举个例子，如果输入abc，它的组合有a、b、c、ab、ac、bc、abc。

   ```java
   /**
        *  利于数二进制解决字符串的组合问题：
        *      由字符串的长度，获取一个相同位数二进制的最大十进制数。
        *      获取十进制数的二进制位上的相应值，0不输出，1输出，十进制数减一。循环上述过程，直至十进制小于等于0.
        *      
        *   基于位图的思路：假设原有元素 n 个，则最终组合结果是 2n−1 个。
        *   我们可以用位操作方法：假设元素原本有：a,b,c 三个，则 1 表示取该元素，0 表示不取。
        * @param str
        */
       public static void calcAllCombination(char[] str){
           int length = str.length;
           long num = (long)Math.pow(2, length) - 1;
           do {
               long tmp = num;
               for (int i = 0 ; i < length ; i++){
                   if (tmp%2 == 1)
                       System.out.print(str[i]);
                   tmp /= 2;
               }
               System.out.println();
           }while (--num >= 0);
       }
   ```

   ## 7. 字符串或链表练习题

   1. **第一个只出现一次的字符**

      在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。

      **思路**：使用HashTable进行记录，字符作为key，value为出现次数，这样便可在O(n)的时间内得出结果。

   2. **对称子字符串的最大长度**

      输入一个字符串，输出该字符串中对称的子字符串的最大长度。比如输入字符串“google”，由于该字符串里最长的对称子字符串是“goog”，因此输出4。

      **思路**：对称字符串即回文串，参考专题5。

   3. **编程判断俩个链表是否相交**

      3.1 给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。为了简化问题，我们假设俩个链表均不带环。

      **思路**：①判断两链表最后一个节点是否相同，如果相交，则尾节点肯定是同一节点；②人为构环，将链表A的尾节点指向链表B，再判断是否构环成功？从链表B的头指针往下遍历，如果能够回到B，则说明相交。

      3.2 如果3.1题目中链表可能有环列?

      **思路**：先判断是否有环，判断是否有环可以使用追逐办法，设置两个指针，一个走一步，一个走两步，如果能相遇则说明存在环。（1）两个都没环：回到问题3.1；（2）一个有环，一个没环：不用判断了，肯定两链表不相交；（3）两个都有环：判断链表A的碰撞点是否出现在链表B的环中，如果在，则相交。（相交时，环必定是两链表共有的）

      3.3 如何寻找两相交链表（不知是否有环）的第一个相交节点？

      **思路**：使用追逐办法先判断是否存在环，分情况讨论（1）无环：人为构环，将链表A的尾节点指向链表B，则构成一个带环的单链表。这个问题就转换成寻找带环单链表的环入口节点。解法参考：http://blog.csdn.net/liuxialong/archive/2011/06/20/6555850.aspx（2）有环：计算出两链表的长度lA、lB，（环的长度和环到入口点长度之和就是链表长度）计算带环链表长度，可参考http://blog.csdn.net/liuxialong/archive/2011/06/20/6555850.aspx

      如果lA>lB，则链表A指针先走lA-lB，然后链表B指针开始走，两者相遇的点就是相交点

      如果lB>lA，则链表B指针先走lB-lA，然后链表A指针开始走，两者相遇的点就是相交点

   4. **在O(1)时间内删除单链表结点**

      给定单链表的一个结点的指针，同时该结点不是尾结点，此外没有指向其它任何结点的指针，请在O(1)时间内删除该结点。

      **思路**：通过数据拷贝的方式，将需要删除的节点转换为目标节点的下一个节点，此时便可在O(1)的时间内实现删除。

      如果删除的结点位于链表的尾部，没有下一个结点。我们仍然从链表的头结点开始，遍历得到给定结点的前序结点，完成删除操作。

      假设链表总共有n个结点，我们的算法在n-1总情况下时间复杂度是O(1)，只有当给定的结点处于链表末尾的时候，时间复杂度为O(n)。那么平均时间复杂度[(n-1)*O(1)+O(n)]/n，仍然为O(1)。

   5. **在字符串中删除特定的字符**

      输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入”They are students.”和”aeiou”，则删除之后的第一个字符串变成”Thy r stdnts.”。

      **思路**：对于这个问题，我们主要解决两个问题，字符的查找和字符的删除。对于字符的查找，我们可以使用set<>来存放需要被删除的字符，然后在需要被删除的查找时，时间复杂度0(1)；对于字符串中字符的删除问题，由删除而导致字符的大量移动可以使用逆向思维来优化，变查找需要删除的改为查找需要保留的，具体的做法：借助两个指针，一个指针从头至尾接受另一个指针的复制而前进，而另一个指针是遇到需要删除的就什么不做，遇到需要保留的字符时则复制给前方指针。

      [代码：str-7.5.java]()

   6. **最长重复子串**

      一个长度为10000的字符串，写一个算法，找出最长的重复子串，如abczzacbca,结果是bc。

      提示：此题是后缀树/数组的典型应用，即是求后缀数组的height[]的最大值。

      **思路**：

      ​

